# VirtualModule

If you have ever felt at all disappointed seeing Ruby's computational performance particularly for large-scale scientific computation, VirtualModule may save you a little. It offers you a way to run your arbitrary Ruby code on the other language VM process(currently only Julia is supported). What make VirtualModule possible to do this is [ruby2julia transpiler](https://github.com/remore/julializer)(which is at very early stage of development) and IPC using [msgpack](http://msgpack.org/).

Let's take a look at results of [benchmark program](https://github.com/remore/virtual_module/blob/master/doc/benchmark_loop_performance/add_two_floating_numbers_cumulatively.rb) of which scores were taken on my MacBook Pro(OSX10.11, Core i5 2.9GHz, 8GB). Essentially this benchmarking program just repeats adding an integer value to floating point value cumulatively(which is represented as `x=2.5; 1.upto(N){|i| x=x+i}` in Ruby). If you run this program with setting of smaller number of loops, VirtualModule doesn't make sense at all as you can see:

![Benchmarking results](https://raw.githubusercontent.com/remore/virtual_module/master/doc/assets/benchmark-result-from-1e1-to-1e7.png "Graphs of average execution time vs number of loops(MacBook Pro)")

However as the number of loops gets bigger, VirtualModule significantly reduces total execution time. (For the sake of honor of python, here is [another benchmarking results](link_to_the_graph_in_case_of_Ubuntu) measured on Ubuntu16 on DigitalOcean. It records better score of python2.7 than the one with my MacBook Pro, although I'm not sure why this happens.)

![Benchmarking results](https://raw.githubusercontent.com/remore/virtual_module/master/doc/assets/benchmark-result-from-1e1-to-1e9.png "Graphs of average execution time vs number of loops(MacBook Pro)")

The other example here is a [prototype word2vec implementation in Ruby](https://github.com/remore/virtual_module/blob/master/example/word2vec.rb), which is just partially ported from [the one created by Tomas Mikolov at Google](https://code.google.com/archive/p/word2vec/). Since it's not optimized very well yet due to my limited time to work on this example, it doesn't record decent score in terms of speed yet, but it reveals at least the fact that VirtualModule will reduces total execution time considerably even in real world example.

(ToDo: insert an image here of benchmarking result of three types of word2vec implementation)

Of course the vector binary file generated by VirtualModule is available using gemsim for example(I guess few people use this immature implementation, but just to make sure that the binary file works fine, let me please note these command logs):

```
$ ruby example/word2vec.rb --output ./output/word_vectors.bin --train ./training_data/1mb.txt --size 20 --window 10 --negative 5 --sample 1e-4 --binary 1 --iter 3 --debug 0
$ python
>>> import gensim
>>> model = gensim.models.Word2Vec.load_word2vec_format('/tmp/original_10m.bin', binary=True)
>>> model.most_similar("one")
[(u'eight', 0.9879311323165894), (u'seven', 0.9774171113967896), (u'six', 0.9648457765579224), (u'nine', 0.933282732963562), (u'four', 0.9331086874008179), (u'marina', 0.9280896186828613), (u'luxembourg', 0.9247918128967285), (u'philippe', 0.9187813997268677), (u'charted', 0.916327953338623), (u'nd', 0.9108971357345581)]
```

## Usage and How it works(TBD)

VirtualModule is a Module generator which has only one public api named `VirtualModule#new`. In the following example, VirtualModule returns a new Module which have two public method `#hi` and `#hello`. Since `vm `object is a instance of Module class, you can simply include `vm` object and call `#hello` method in this case.

```
require 'virtual_module'
vm = VirtualModule.new(<<EOS)
def hi
  "ho"
end

def hello(num)
  num*num
end
EOS
p vm.hi # "ho"
include vm
p hello(33) # 1089
```

What VirtualModule do at the code above is something like below:

 - Transpile `#def` and `#hello` methods into Julia code, using [julializer] rubygem.
 - Boot the transpiled code and pass the parameters via msgpack-ruby and MsgPack.jl
 - Run #hi or #hello function call on the Julia VM
 - Pass returend value back to ruby via msgpack-ruby and MsgPack.jl

Another important api I'm introducing is `virtual_module_eval`. With this method, you can bind your local variable to Julia. Yey!

```
vm = VirtualModule.new(<<EOS)
def hey(x,y)
  y[2] += x
end
a = 2016
b = [99, "foobar", 3.1415]
vm.virtual_module_eval(a,b)
puts b # 2019.1415
```

## Build Your Own IPCInterface

TBD

## Requirement

- Mac OSX, Linux and Ruby(MRI) 2.1 and higher are supported.
- Either Julia or Docker inslalled on your machine is a must, although installing Julia is highly recommended for the performance reason.

## Installation

Simply run the following command.

```
$ gem install virtual_module
$ julia -e 'Pkg.add("MsgPack"); Pkg.add("MsgPackRpcServer")'
```

## Features

Following features are implemented already:

- File-based IPC using [msgpack-ruby](https://github.com/msgpack/msgpack-ruby) and [MsgPack.jl](https://github.com/kmsquire/MsgPack.jl/)
- RPC-based IPC using [msgpack-ruby](https://github.com/msgpack/msgpack-ruby) and [MsgPackRpcServer.jl](https://github.com/remore/MsgPackRpcServer.jl)

features to be implemented in the future(if needed/requested) are listed as follows:

- Improve julializer(transpiler) much better
- Other programming language support such as golang, ruby itself etc.

## License

MIT
